{"version":3,"sources":["serviceWorker.js"],"names":["CACHE_NAME","urlsToCache","self","addEventListener","e","waitUntil","caches","open","then","cache","addAll","skipWaiting","catch","err","console","log","cacheWhitelist","keys","cacheNames","map","cacheName","indexOf","delete","clients","claim","respondWith","match","request","res","fetch"],"mappings":"AAAA,MAAMA,WAAa,8BACnBC,YAAc,CACV,KACA,oGACA,oBACA,kBACA,qBACA,sBACA,aAIJC,KAAKC,iBAAiB,UAAWC,IAC7BA,EAAEC,UACEC,OAAOC,KAAKP,YACPQ,KAAKC,GACKA,EAAMC,OAAOT,aACfO,KAAK,IAAMN,KAAKS,gBAE5BC,MAAMC,GAAOC,QAAQC,IAAI,0BAA2BF,OAK7DX,KAAKC,iBAAiB,SAAUC,IAC5B,MAAMY,EAAiB,CAAChB,YAExBI,EAAEC,UACEC,OAAOW,OACFT,KAAKU,IACFA,EAAWC,IAAIC,IAEX,IAA0C,IAAvCJ,EAAeK,QAAQD,GACtB,OAAOd,OAAOgB,OAAOF,OAKpCZ,KAAK,IAAMN,KAAKqB,QAAQC,YAKjCtB,KAAKC,iBAAiB,QAASC,IAE3BA,EAAEqB,YACEnB,OAAOoB,MAAMtB,EAAEuB,SACVnB,KAAMoB,GACAA,GAOIC,MAAMzB,EAAEuB","file":"serviceWorker.js","sourcesContent":["const CACHE_NAME = 'v1_cache_atravezdelvehiculo',\r\nurlsToCache = [\r\n    './',\r\n    'https://fonts.googleapis.com/css2?family=Source+Sans+Pro:ital,wght@0,300;0,400;1,700&display=swap',\r\n    'build/css/app.css',\r\n    'build/js/app.js',\r\n    'build/js/slider.js',\r\n    'build/js/service.js',\r\n    'build/img'\r\n]\r\n\r\n//Almacena en cache los activos estaticos\r\nself.addEventListener('install', e => {\r\n    e.waitUntil(\r\n        caches.open(CACHE_NAME)\r\n            .then(cache => {\r\n                return cache.addAll(urlsToCache)\r\n                    .then(() => self.skipWaiting())\r\n            })\r\n        .catch(err => console.log('Fallo registro de cache', err))\r\n    )\r\n})\r\n\r\n//Una vez instalado el SW, se activa y busca los recursos para hacer que funcione sin conexión\r\nself.addEventListener('active', e => {\r\n    const cacheWhitelist = [CACHE_NAME]\r\n\r\n    e.waitUntil(\r\n        caches.keys()\r\n            .then(cacheNames => {\r\n                cacheNames.map(cacheName => {\r\n                    //Elimina lo que ya no se necesita en el cache\r\n                    if(cacheWhitelist.indexOf(cacheName) === -1 ){\r\n                        return caches.delete(cacheName)\r\n                    }\r\n                })\r\n            })\r\n        //Le indicamos al SW activar el cache actual\r\n        .then(() => self.clients.claim())\r\n    )\r\n})\r\n\r\n//Recuperar todos los recuros del navegador\r\nself.addEventListener('fetch', e => {\r\n    //Responder ya sea con el objeto en caché o continuar y buscar la url real\r\n    e.respondWith(\r\n        caches.match(e.request)\r\n            .then (res => {\r\n                if(res) {\r\n                    //recuperar cache\r\n                    return res\r\n                }\r\n\r\n\r\n                //Recuperar la peticion del URL\r\n                return fetch(e.request)\r\n            })\r\n    )\r\n})"]}